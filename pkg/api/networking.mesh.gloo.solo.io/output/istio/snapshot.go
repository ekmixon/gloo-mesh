// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./snapshot.go -destination mocks/snapshot.go

// Definitions for Output Snapshots
package istio

import (
	"context"
	"encoding/json"
	"sort"

	snapshotutils "github.com/solo-io/skv2/contrib/pkg/snapshot"

	"github.com/solo-io/skv2/pkg/multicluster"
	"github.com/solo-io/skv2/pkg/resource"
	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/rotisserie/eris"
	"github.com/solo-io/skv2/contrib/pkg/output"
	"github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"sigs.k8s.io/controller-runtime/pkg/client"

	certificates_mesh_gloo_solo_io_v1 "github.com/solo-io/gloo-mesh/pkg/api/certificates.mesh.gloo.solo.io/v1"
	certificates_mesh_gloo_solo_io_v1_sets "github.com/solo-io/gloo-mesh/pkg/api/certificates.mesh.gloo.solo.io/v1/sets"

	xds_agent_enterprise_mesh_gloo_solo_io_v1beta1 "github.com/solo-io/gloo-mesh/pkg/api/xds.agent.enterprise.mesh.gloo.solo.io/v1beta1"
	xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets "github.com/solo-io/gloo-mesh/pkg/api/xds.agent.enterprise.mesh.gloo.solo.io/v1beta1/sets"

	networking_istio_io_v1alpha3_sets "github.com/solo-io/external-apis/pkg/api/istio/networking.istio.io/v1alpha3/sets"
	networking_istio_io_v1alpha3 "istio.io/client-go/pkg/apis/networking/v1alpha3"

	security_istio_io_v1beta1_sets "github.com/solo-io/external-apis/pkg/api/istio/security.istio.io/v1beta1/sets"
	security_istio_io_v1beta1 "istio.io/client-go/pkg/apis/security/v1beta1"

	ratelimit_solo_io_v1alpha1 "github.com/solo-io/solo-apis/pkg/api/ratelimit.solo.io/v1alpha1"
	ratelimit_solo_io_v1alpha1_sets "github.com/solo-io/solo-apis/pkg/api/ratelimit.solo.io/v1alpha1/sets"
)

// this error can occur if constructing a Partitioned Snapshot from a resource
// that is missing the partition label
var MissingRequiredLabelError = func(labelKey string, gvk schema.GroupVersionKind, obj ezkube.ResourceId) error {
	return eris.Errorf("expected label %v not on labels of %v %v", labelKey, gvk.String(), sets.Key(obj))
}

// SnapshotGVKs is a list of the GVKs included in this snapshot
var SnapshotGVKs = []schema.GroupVersionKind{
	schema.GroupVersionKind{
		Group:   "certificates.mesh.gloo.solo.io",
		Version: "v1",
		Kind:    "IssuedCertificate",
	},
	schema.GroupVersionKind{
		Group:   "certificates.mesh.gloo.solo.io",
		Version: "v1",
		Kind:    "PodBounceDirective",
	},
	schema.GroupVersionKind{
		Group:   "xds.agent.enterprise.mesh.gloo.solo.io",
		Version: "v1beta1",
		Kind:    "XdsConfig",
	},
	schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "DestinationRule",
	},
	schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "EnvoyFilter",
	},
	schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "Gateway",
	},
	schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "ServiceEntry",
	},
	schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "VirtualService",
	},
	schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "Sidecar",
	},
	schema.GroupVersionKind{
		Group:   "security.istio.io",
		Version: "v1beta1",
		Kind:    "AuthorizationPolicy",
	},
	schema.GroupVersionKind{
		Group:   "ratelimit.solo.io",
		Version: "v1alpha1",
		Kind:    "RateLimitConfig",
	},
}

// the snapshot of output resources produced by a translation
type Snapshot interface {

	// return the set of IssuedCertificates with a given set of labels
	IssuedCertificates() []LabeledIssuedCertificateSet
	// return the set of PodBounceDirectives with a given set of labels
	PodBounceDirectives() []LabeledPodBounceDirectiveSet
	// return the set of XdsConfigs with a given set of labels
	XdsConfigs() []LabeledXdsConfigSet
	// return the set of DestinationRules with a given set of labels
	DestinationRules() []LabeledDestinationRuleSet
	// return the set of EnvoyFilters with a given set of labels
	EnvoyFilters() []LabeledEnvoyFilterSet
	// return the set of Gateways with a given set of labels
	Gateways() []LabeledGatewaySet
	// return the set of ServiceEntries with a given set of labels
	ServiceEntries() []LabeledServiceEntrySet
	// return the set of VirtualServices with a given set of labels
	VirtualServices() []LabeledVirtualServiceSet
	// return the set of Sidecars with a given set of labels
	Sidecars() []LabeledSidecarSet
	// return the set of AuthorizationPolicies with a given set of labels
	AuthorizationPolicies() []LabeledAuthorizationPolicySet
	// return the set of RateLimitConfigs with a given set of labels
	RateLimitConfigs() []LabeledRateLimitConfigSet

	// apply the snapshot to the local cluster, garbage collecting stale resources
	ApplyLocalCluster(ctx context.Context, clusterClient client.Client, opts output.OutputOpts)

	// apply resources from the snapshot across multiple clusters, garbage collecting stale resources
	ApplyMultiCluster(ctx context.Context, multiClusterClient multicluster.Client, opts output.OutputOpts)

	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)

	// convert this snapshot to its generic form
	Generic() resource.ClusterSnapshot

	// iterate over the objects contained in the snapshot
	ForEachObject(handleObject func(cluster string, gvk schema.GroupVersionKind, obj resource.TypedObject))
}

type snapshot struct {
	name string

	issuedCertificates    []LabeledIssuedCertificateSet
	podBounceDirectives   []LabeledPodBounceDirectiveSet
	xdsConfigs            []LabeledXdsConfigSet
	destinationRules      []LabeledDestinationRuleSet
	envoyFilters          []LabeledEnvoyFilterSet
	gateways              []LabeledGatewaySet
	serviceEntries        []LabeledServiceEntrySet
	virtualServices       []LabeledVirtualServiceSet
	sidecars              []LabeledSidecarSet
	authorizationPolicies []LabeledAuthorizationPolicySet
	rateLimitConfigs      []LabeledRateLimitConfigSet
	clusters              []string
}

func NewSnapshot(
	name string,

	issuedCertificates []LabeledIssuedCertificateSet,
	podBounceDirectives []LabeledPodBounceDirectiveSet,
	xdsConfigs []LabeledXdsConfigSet,
	destinationRules []LabeledDestinationRuleSet,
	envoyFilters []LabeledEnvoyFilterSet,
	gateways []LabeledGatewaySet,
	serviceEntries []LabeledServiceEntrySet,
	virtualServices []LabeledVirtualServiceSet,
	sidecars []LabeledSidecarSet,
	authorizationPolicies []LabeledAuthorizationPolicySet,
	rateLimitConfigs []LabeledRateLimitConfigSet,
	clusters ...string, // the set of clusters to apply the snapshot to. only required for multicluster snapshots.
) Snapshot {
	return &snapshot{
		name: name,

		issuedCertificates:    issuedCertificates,
		podBounceDirectives:   podBounceDirectives,
		xdsConfigs:            xdsConfigs,
		destinationRules:      destinationRules,
		envoyFilters:          envoyFilters,
		gateways:              gateways,
		serviceEntries:        serviceEntries,
		virtualServices:       virtualServices,
		sidecars:              sidecars,
		authorizationPolicies: authorizationPolicies,
		rateLimitConfigs:      rateLimitConfigs,
		clusters:              clusters,
	}
}

// automatically partitions the input resources
// by the presence of the provided label.
func NewLabelPartitionedSnapshot(
	name,
	labelKey string, // the key by which to partition the resources

	issuedCertificates certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet,
	podBounceDirectives certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet,

	xdsConfigs xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.XdsConfigSet,

	destinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet,
	envoyFilters networking_istio_io_v1alpha3_sets.EnvoyFilterSet,
	gateways networking_istio_io_v1alpha3_sets.GatewaySet,
	serviceEntries networking_istio_io_v1alpha3_sets.ServiceEntrySet,
	virtualServices networking_istio_io_v1alpha3_sets.VirtualServiceSet,
	sidecars networking_istio_io_v1alpha3_sets.SidecarSet,

	authorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet,

	rateLimitConfigs ratelimit_solo_io_v1alpha1_sets.RateLimitConfigSet,
	clusters ...string, // the set of clusters to apply the snapshot to. only required for multicluster snapshots.
) (Snapshot, error) {

	partitionedIssuedCertificates, err := partitionIssuedCertificatesByLabel(labelKey, issuedCertificates)
	if err != nil {
		return nil, err
	}
	partitionedPodBounceDirectives, err := partitionPodBounceDirectivesByLabel(labelKey, podBounceDirectives)
	if err != nil {
		return nil, err
	}
	partitionedXdsConfigs, err := partitionXdsConfigsByLabel(labelKey, xdsConfigs)
	if err != nil {
		return nil, err
	}
	partitionedDestinationRules, err := partitionDestinationRulesByLabel(labelKey, destinationRules)
	if err != nil {
		return nil, err
	}
	partitionedEnvoyFilters, err := partitionEnvoyFiltersByLabel(labelKey, envoyFilters)
	if err != nil {
		return nil, err
	}
	partitionedGateways, err := partitionGatewaysByLabel(labelKey, gateways)
	if err != nil {
		return nil, err
	}
	partitionedServiceEntries, err := partitionServiceEntriesByLabel(labelKey, serviceEntries)
	if err != nil {
		return nil, err
	}
	partitionedVirtualServices, err := partitionVirtualServicesByLabel(labelKey, virtualServices)
	if err != nil {
		return nil, err
	}
	partitionedSidecars, err := partitionSidecarsByLabel(labelKey, sidecars)
	if err != nil {
		return nil, err
	}
	partitionedAuthorizationPolicies, err := partitionAuthorizationPoliciesByLabel(labelKey, authorizationPolicies)
	if err != nil {
		return nil, err
	}
	partitionedRateLimitConfigs, err := partitionRateLimitConfigsByLabel(labelKey, rateLimitConfigs)
	if err != nil {
		return nil, err
	}

	return NewSnapshot(
		name,

		partitionedIssuedCertificates,
		partitionedPodBounceDirectives,
		partitionedXdsConfigs,
		partitionedDestinationRules,
		partitionedEnvoyFilters,
		partitionedGateways,
		partitionedServiceEntries,
		partitionedVirtualServices,
		partitionedSidecars,
		partitionedAuthorizationPolicies,
		partitionedRateLimitConfigs,
		clusters...,
	), nil
}

// simplified constructor for a snapshot
// with a single label partition (i.e. all resources share a single set of labels).
func NewSinglePartitionedSnapshot(
	name string,
	snapshotLabels map[string]string, // a single set of labels shared by all resources

	issuedCertificates certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet,
	podBounceDirectives certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet,

	xdsConfigs xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.XdsConfigSet,

	destinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet,
	envoyFilters networking_istio_io_v1alpha3_sets.EnvoyFilterSet,
	gateways networking_istio_io_v1alpha3_sets.GatewaySet,
	serviceEntries networking_istio_io_v1alpha3_sets.ServiceEntrySet,
	virtualServices networking_istio_io_v1alpha3_sets.VirtualServiceSet,
	sidecars networking_istio_io_v1alpha3_sets.SidecarSet,

	authorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet,

	rateLimitConfigs ratelimit_solo_io_v1alpha1_sets.RateLimitConfigSet,
	clusters ...string, // the set of clusters to apply the snapshot to. only required for multicluster snapshots.
) (Snapshot, error) {

	labeledIssuedCertificates, err := NewLabeledIssuedCertificateSet(issuedCertificates, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledPodBounceDirectives, err := NewLabeledPodBounceDirectiveSet(podBounceDirectives, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledXdsConfigs, err := NewLabeledXdsConfigSet(xdsConfigs, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledDestinationRules, err := NewLabeledDestinationRuleSet(destinationRules, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledEnvoyFilters, err := NewLabeledEnvoyFilterSet(envoyFilters, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledGateways, err := NewLabeledGatewaySet(gateways, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledServiceEntries, err := NewLabeledServiceEntrySet(serviceEntries, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledVirtualServices, err := NewLabeledVirtualServiceSet(virtualServices, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledSidecars, err := NewLabeledSidecarSet(sidecars, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledAuthorizationPolicies, err := NewLabeledAuthorizationPolicySet(authorizationPolicies, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledRateLimitConfigs, err := NewLabeledRateLimitConfigSet(rateLimitConfigs, snapshotLabels)
	if err != nil {
		return nil, err
	}

	return NewSnapshot(
		name,

		[]LabeledIssuedCertificateSet{labeledIssuedCertificates},
		[]LabeledPodBounceDirectiveSet{labeledPodBounceDirectives},
		[]LabeledXdsConfigSet{labeledXdsConfigs},
		[]LabeledDestinationRuleSet{labeledDestinationRules},
		[]LabeledEnvoyFilterSet{labeledEnvoyFilters},
		[]LabeledGatewaySet{labeledGateways},
		[]LabeledServiceEntrySet{labeledServiceEntries},
		[]LabeledVirtualServiceSet{labeledVirtualServices},
		[]LabeledSidecarSet{labeledSidecars},
		[]LabeledAuthorizationPolicySet{labeledAuthorizationPolicies},
		[]LabeledRateLimitConfigSet{labeledRateLimitConfigs},
		clusters...,
	), nil
}

// apply the desired resources to the cluster state; remove stale resources where necessary
func (s *snapshot) ApplyLocalCluster(ctx context.Context, clusterClient client.Client, opts output.OutputOpts) {
	var genericLists []output.ResourceList

	for _, outputSet := range s.issuedCertificates {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.podBounceDirectives {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.xdsConfigs {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.destinationRules {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.envoyFilters {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.gateways {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.serviceEntries {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.virtualServices {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.sidecars {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.authorizationPolicies {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.rateLimitConfigs {
		genericLists = append(genericLists, outputSet.Generic())
	}

	output.Snapshot{
		Name:        s.name,
		ListsToSync: genericLists,
	}.SyncLocalCluster(ctx, clusterClient, opts)
}

// apply the desired resources to multiple cluster states; remove stale resources where necessary
func (s *snapshot) ApplyMultiCluster(ctx context.Context, multiClusterClient multicluster.Client, opts output.OutputOpts) {
	var genericLists []output.ResourceList

	for _, outputSet := range s.issuedCertificates {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.podBounceDirectives {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.xdsConfigs {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.destinationRules {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.envoyFilters {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.gateways {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.serviceEntries {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.virtualServices {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.sidecars {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.authorizationPolicies {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.rateLimitConfigs {
		genericLists = append(genericLists, outputSet.Generic())
	}

	output.Snapshot{
		Name:        s.name,
		Clusters:    s.clusters,
		ListsToSync: genericLists,
	}.SyncMultiCluster(ctx, multiClusterClient, opts)
}

func (s *snapshot) Generic() resource.ClusterSnapshot {
	clusterSnapshots := resource.ClusterSnapshot{}
	s.ForEachObject(func(cluster string, gvk schema.GroupVersionKind, obj resource.TypedObject) {
		clusterSnapshots.Insert(cluster, gvk, obj)
	})

	return clusterSnapshots
}

// convert this snapshot to its generic form
func (s *snapshot) ForEachObject(handleObject func(cluster string, gvk schema.GroupVersionKind, obj resource.TypedObject)) {

	for _, set := range s.issuedCertificates {
		for _, obj := range set.Set().List() {
			cluster := obj.GetClusterName()
			gvk := schema.GroupVersionKind{
				Group:   "certificates.mesh.gloo.solo.io",
				Version: "v1",
				Kind:    "IssuedCertificate",
			}
			handleObject(cluster, gvk, obj)
		}
	}
	for _, set := range s.podBounceDirectives {
		for _, obj := range set.Set().List() {
			cluster := obj.GetClusterName()
			gvk := schema.GroupVersionKind{
				Group:   "certificates.mesh.gloo.solo.io",
				Version: "v1",
				Kind:    "PodBounceDirective",
			}
			handleObject(cluster, gvk, obj)
		}
	}

	for _, set := range s.xdsConfigs {
		for _, obj := range set.Set().List() {
			cluster := obj.GetClusterName()
			gvk := schema.GroupVersionKind{
				Group:   "xds.agent.enterprise.mesh.gloo.solo.io",
				Version: "v1beta1",
				Kind:    "XdsConfig",
			}
			handleObject(cluster, gvk, obj)
		}
	}

	for _, set := range s.destinationRules {
		for _, obj := range set.Set().List() {
			cluster := obj.GetClusterName()
			gvk := schema.GroupVersionKind{
				Group:   "networking.istio.io",
				Version: "v1alpha3",
				Kind:    "DestinationRule",
			}
			handleObject(cluster, gvk, obj)
		}
	}
	for _, set := range s.envoyFilters {
		for _, obj := range set.Set().List() {
			cluster := obj.GetClusterName()
			gvk := schema.GroupVersionKind{
				Group:   "networking.istio.io",
				Version: "v1alpha3",
				Kind:    "EnvoyFilter",
			}
			handleObject(cluster, gvk, obj)
		}
	}
	for _, set := range s.gateways {
		for _, obj := range set.Set().List() {
			cluster := obj.GetClusterName()
			gvk := schema.GroupVersionKind{
				Group:   "networking.istio.io",
				Version: "v1alpha3",
				Kind:    "Gateway",
			}
			handleObject(cluster, gvk, obj)
		}
	}
	for _, set := range s.serviceEntries {
		for _, obj := range set.Set().List() {
			cluster := obj.GetClusterName()
			gvk := schema.GroupVersionKind{
				Group:   "networking.istio.io",
				Version: "v1alpha3",
				Kind:    "ServiceEntry",
			}
			handleObject(cluster, gvk, obj)
		}
	}
	for _, set := range s.virtualServices {
		for _, obj := range set.Set().List() {
			cluster := obj.GetClusterName()
			gvk := schema.GroupVersionKind{
				Group:   "networking.istio.io",
				Version: "v1alpha3",
				Kind:    "VirtualService",
			}
			handleObject(cluster, gvk, obj)
		}
	}
	for _, set := range s.sidecars {
		for _, obj := range set.Set().List() {
			cluster := obj.GetClusterName()
			gvk := schema.GroupVersionKind{
				Group:   "networking.istio.io",
				Version: "v1alpha3",
				Kind:    "Sidecar",
			}
			handleObject(cluster, gvk, obj)
		}
	}

	for _, set := range s.authorizationPolicies {
		for _, obj := range set.Set().List() {
			cluster := obj.GetClusterName()
			gvk := schema.GroupVersionKind{
				Group:   "security.istio.io",
				Version: "v1beta1",
				Kind:    "AuthorizationPolicy",
			}
			handleObject(cluster, gvk, obj)
		}
	}

	for _, set := range s.rateLimitConfigs {
		for _, obj := range set.Set().List() {
			cluster := obj.GetClusterName()
			gvk := schema.GroupVersionKind{
				Group:   "ratelimit.solo.io",
				Version: "v1alpha1",
				Kind:    "RateLimitConfig",
			}
			handleObject(cluster, gvk, obj)
		}
	}
}

func partitionIssuedCertificatesByLabel(labelKey string, set certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet) ([]LabeledIssuedCertificateSet, error) {
	setsByLabel := map[string]certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet{}

	for _, obj := range set.List() {
		objGVK := schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "IssuedCertificate",
		}
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = certificates_mesh_gloo_solo_io_v1_sets.NewIssuedCertificateSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedIssuedCertificates []LabeledIssuedCertificateSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledIssuedCertificateSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedIssuedCertificates = append(partitionedIssuedCertificates, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedIssuedCertificates, func(i, j int) bool {
		leftLabelValue := partitionedIssuedCertificates[i].Labels()[labelKey]
		rightLabelValue := partitionedIssuedCertificates[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedIssuedCertificates, nil
}

func partitionPodBounceDirectivesByLabel(labelKey string, set certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet) ([]LabeledPodBounceDirectiveSet, error) {
	setsByLabel := map[string]certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet{}

	for _, obj := range set.List() {
		objGVK := schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "PodBounceDirective",
		}
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = certificates_mesh_gloo_solo_io_v1_sets.NewPodBounceDirectiveSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedPodBounceDirectives []LabeledPodBounceDirectiveSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledPodBounceDirectiveSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedPodBounceDirectives = append(partitionedPodBounceDirectives, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedPodBounceDirectives, func(i, j int) bool {
		leftLabelValue := partitionedPodBounceDirectives[i].Labels()[labelKey]
		rightLabelValue := partitionedPodBounceDirectives[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedPodBounceDirectives, nil
}

func partitionXdsConfigsByLabel(labelKey string, set xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.XdsConfigSet) ([]LabeledXdsConfigSet, error) {
	setsByLabel := map[string]xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.XdsConfigSet{}

	for _, obj := range set.List() {
		objGVK := schema.GroupVersionKind{
			Group:   "xds.agent.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "XdsConfig",
		}
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewXdsConfigSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedXdsConfigs []LabeledXdsConfigSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledXdsConfigSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedXdsConfigs = append(partitionedXdsConfigs, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedXdsConfigs, func(i, j int) bool {
		leftLabelValue := partitionedXdsConfigs[i].Labels()[labelKey]
		rightLabelValue := partitionedXdsConfigs[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedXdsConfigs, nil
}

func partitionDestinationRulesByLabel(labelKey string, set networking_istio_io_v1alpha3_sets.DestinationRuleSet) ([]LabeledDestinationRuleSet, error) {
	setsByLabel := map[string]networking_istio_io_v1alpha3_sets.DestinationRuleSet{}

	for _, obj := range set.List() {
		objGVK := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "DestinationRule",
		}
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = networking_istio_io_v1alpha3_sets.NewDestinationRuleSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedDestinationRules []LabeledDestinationRuleSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledDestinationRuleSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedDestinationRules = append(partitionedDestinationRules, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedDestinationRules, func(i, j int) bool {
		leftLabelValue := partitionedDestinationRules[i].Labels()[labelKey]
		rightLabelValue := partitionedDestinationRules[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedDestinationRules, nil
}

func partitionEnvoyFiltersByLabel(labelKey string, set networking_istio_io_v1alpha3_sets.EnvoyFilterSet) ([]LabeledEnvoyFilterSet, error) {
	setsByLabel := map[string]networking_istio_io_v1alpha3_sets.EnvoyFilterSet{}

	for _, obj := range set.List() {
		objGVK := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "EnvoyFilter",
		}
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedEnvoyFilters []LabeledEnvoyFilterSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledEnvoyFilterSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedEnvoyFilters = append(partitionedEnvoyFilters, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedEnvoyFilters, func(i, j int) bool {
		leftLabelValue := partitionedEnvoyFilters[i].Labels()[labelKey]
		rightLabelValue := partitionedEnvoyFilters[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedEnvoyFilters, nil
}

func partitionGatewaysByLabel(labelKey string, set networking_istio_io_v1alpha3_sets.GatewaySet) ([]LabeledGatewaySet, error) {
	setsByLabel := map[string]networking_istio_io_v1alpha3_sets.GatewaySet{}

	for _, obj := range set.List() {
		objGVK := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "Gateway",
		}
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = networking_istio_io_v1alpha3_sets.NewGatewaySet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedGateways []LabeledGatewaySet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledGatewaySet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedGateways = append(partitionedGateways, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedGateways, func(i, j int) bool {
		leftLabelValue := partitionedGateways[i].Labels()[labelKey]
		rightLabelValue := partitionedGateways[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedGateways, nil
}

func partitionServiceEntriesByLabel(labelKey string, set networking_istio_io_v1alpha3_sets.ServiceEntrySet) ([]LabeledServiceEntrySet, error) {
	setsByLabel := map[string]networking_istio_io_v1alpha3_sets.ServiceEntrySet{}

	for _, obj := range set.List() {
		objGVK := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "ServiceEntry",
		}
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = networking_istio_io_v1alpha3_sets.NewServiceEntrySet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedServiceEntries []LabeledServiceEntrySet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledServiceEntrySet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedServiceEntries = append(partitionedServiceEntries, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedServiceEntries, func(i, j int) bool {
		leftLabelValue := partitionedServiceEntries[i].Labels()[labelKey]
		rightLabelValue := partitionedServiceEntries[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedServiceEntries, nil
}

func partitionVirtualServicesByLabel(labelKey string, set networking_istio_io_v1alpha3_sets.VirtualServiceSet) ([]LabeledVirtualServiceSet, error) {
	setsByLabel := map[string]networking_istio_io_v1alpha3_sets.VirtualServiceSet{}

	for _, obj := range set.List() {
		objGVK := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "VirtualService",
		}
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = networking_istio_io_v1alpha3_sets.NewVirtualServiceSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedVirtualServices []LabeledVirtualServiceSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledVirtualServiceSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedVirtualServices = append(partitionedVirtualServices, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedVirtualServices, func(i, j int) bool {
		leftLabelValue := partitionedVirtualServices[i].Labels()[labelKey]
		rightLabelValue := partitionedVirtualServices[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedVirtualServices, nil
}

func partitionSidecarsByLabel(labelKey string, set networking_istio_io_v1alpha3_sets.SidecarSet) ([]LabeledSidecarSet, error) {
	setsByLabel := map[string]networking_istio_io_v1alpha3_sets.SidecarSet{}

	for _, obj := range set.List() {
		objGVK := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "Sidecar",
		}
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = networking_istio_io_v1alpha3_sets.NewSidecarSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedSidecars []LabeledSidecarSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledSidecarSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedSidecars = append(partitionedSidecars, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedSidecars, func(i, j int) bool {
		leftLabelValue := partitionedSidecars[i].Labels()[labelKey]
		rightLabelValue := partitionedSidecars[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedSidecars, nil
}

func partitionAuthorizationPoliciesByLabel(labelKey string, set security_istio_io_v1beta1_sets.AuthorizationPolicySet) ([]LabeledAuthorizationPolicySet, error) {
	setsByLabel := map[string]security_istio_io_v1beta1_sets.AuthorizationPolicySet{}

	for _, obj := range set.List() {
		objGVK := schema.GroupVersionKind{
			Group:   "security.istio.io",
			Version: "v1beta1",
			Kind:    "AuthorizationPolicy",
		}
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = security_istio_io_v1beta1_sets.NewAuthorizationPolicySet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedAuthorizationPolicies []LabeledAuthorizationPolicySet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledAuthorizationPolicySet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedAuthorizationPolicies = append(partitionedAuthorizationPolicies, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedAuthorizationPolicies, func(i, j int) bool {
		leftLabelValue := partitionedAuthorizationPolicies[i].Labels()[labelKey]
		rightLabelValue := partitionedAuthorizationPolicies[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedAuthorizationPolicies, nil
}

func partitionRateLimitConfigsByLabel(labelKey string, set ratelimit_solo_io_v1alpha1_sets.RateLimitConfigSet) ([]LabeledRateLimitConfigSet, error) {
	setsByLabel := map[string]ratelimit_solo_io_v1alpha1_sets.RateLimitConfigSet{}

	for _, obj := range set.List() {
		objGVK := schema.GroupVersionKind{
			Group:   "ratelimit.solo.io",
			Version: "v1alpha1",
			Kind:    "RateLimitConfig",
		}
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, objGVK, obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = ratelimit_solo_io_v1alpha1_sets.NewRateLimitConfigSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedRateLimitConfigs []LabeledRateLimitConfigSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledRateLimitConfigSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedRateLimitConfigs = append(partitionedRateLimitConfigs, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedRateLimitConfigs, func(i, j int) bool {
		leftLabelValue := partitionedRateLimitConfigs[i].Labels()[labelKey]
		rightLabelValue := partitionedRateLimitConfigs[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedRateLimitConfigs, nil
}

func (s snapshot) IssuedCertificates() []LabeledIssuedCertificateSet {
	return s.issuedCertificates
}

func (s snapshot) PodBounceDirectives() []LabeledPodBounceDirectiveSet {
	return s.podBounceDirectives
}

func (s snapshot) XdsConfigs() []LabeledXdsConfigSet {
	return s.xdsConfigs
}

func (s snapshot) DestinationRules() []LabeledDestinationRuleSet {
	return s.destinationRules
}

func (s snapshot) EnvoyFilters() []LabeledEnvoyFilterSet {
	return s.envoyFilters
}

func (s snapshot) Gateways() []LabeledGatewaySet {
	return s.gateways
}

func (s snapshot) ServiceEntries() []LabeledServiceEntrySet {
	return s.serviceEntries
}

func (s snapshot) VirtualServices() []LabeledVirtualServiceSet {
	return s.virtualServices
}

func (s snapshot) Sidecars() []LabeledSidecarSet {
	return s.sidecars
}

func (s snapshot) AuthorizationPolicies() []LabeledAuthorizationPolicySet {
	return s.authorizationPolicies
}

func (s snapshot) RateLimitConfigs() []LabeledRateLimitConfigSet {
	return s.rateLimitConfigs
}

func (s snapshot) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	issuedCertificateSet := certificates_mesh_gloo_solo_io_v1_sets.NewIssuedCertificateSet()
	for _, set := range s.issuedCertificates {
		for _, obj := range set.Set().UnsortedList() {
			// redact secret data from the snapshot
			obj := snapshotutils.RedactSecretData(obj)
			issuedCertificateSet.Insert(obj.(*certificates_mesh_gloo_solo_io_v1.IssuedCertificate))
		}
	}
	snapshotMap["issuedCertificates"] = issuedCertificateSet.List()
	podBounceDirectiveSet := certificates_mesh_gloo_solo_io_v1_sets.NewPodBounceDirectiveSet()
	for _, set := range s.podBounceDirectives {
		for _, obj := range set.Set().UnsortedList() {
			// redact secret data from the snapshot
			obj := snapshotutils.RedactSecretData(obj)
			podBounceDirectiveSet.Insert(obj.(*certificates_mesh_gloo_solo_io_v1.PodBounceDirective))
		}
	}
	snapshotMap["podBounceDirectives"] = podBounceDirectiveSet.List()

	xdsConfigSet := xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewXdsConfigSet()
	for _, set := range s.xdsConfigs {
		for _, obj := range set.Set().UnsortedList() {
			// redact secret data from the snapshot
			obj := snapshotutils.RedactSecretData(obj)
			xdsConfigSet.Insert(obj.(*xds_agent_enterprise_mesh_gloo_solo_io_v1beta1.XdsConfig))
		}
	}
	snapshotMap["xdsConfigs"] = xdsConfigSet.List()

	destinationRuleSet := networking_istio_io_v1alpha3_sets.NewDestinationRuleSet()
	for _, set := range s.destinationRules {
		for _, obj := range set.Set().UnsortedList() {
			// redact secret data from the snapshot
			obj := snapshotutils.RedactSecretData(obj)
			destinationRuleSet.Insert(obj.(*networking_istio_io_v1alpha3.DestinationRule))
		}
	}
	snapshotMap["destinationRules"] = destinationRuleSet.List()
	envoyFilterSet := networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet()
	for _, set := range s.envoyFilters {
		for _, obj := range set.Set().UnsortedList() {
			// redact secret data from the snapshot
			obj := snapshotutils.RedactSecretData(obj)
			envoyFilterSet.Insert(obj.(*networking_istio_io_v1alpha3.EnvoyFilter))
		}
	}
	snapshotMap["envoyFilters"] = envoyFilterSet.List()
	gatewaySet := networking_istio_io_v1alpha3_sets.NewGatewaySet()
	for _, set := range s.gateways {
		for _, obj := range set.Set().UnsortedList() {
			// redact secret data from the snapshot
			obj := snapshotutils.RedactSecretData(obj)
			gatewaySet.Insert(obj.(*networking_istio_io_v1alpha3.Gateway))
		}
	}
	snapshotMap["gateways"] = gatewaySet.List()
	serviceEntrySet := networking_istio_io_v1alpha3_sets.NewServiceEntrySet()
	for _, set := range s.serviceEntries {
		for _, obj := range set.Set().UnsortedList() {
			// redact secret data from the snapshot
			obj := snapshotutils.RedactSecretData(obj)
			serviceEntrySet.Insert(obj.(*networking_istio_io_v1alpha3.ServiceEntry))
		}
	}
	snapshotMap["serviceEntries"] = serviceEntrySet.List()
	virtualServiceSet := networking_istio_io_v1alpha3_sets.NewVirtualServiceSet()
	for _, set := range s.virtualServices {
		for _, obj := range set.Set().UnsortedList() {
			// redact secret data from the snapshot
			obj := snapshotutils.RedactSecretData(obj)
			virtualServiceSet.Insert(obj.(*networking_istio_io_v1alpha3.VirtualService))
		}
	}
	snapshotMap["virtualServices"] = virtualServiceSet.List()
	sidecarSet := networking_istio_io_v1alpha3_sets.NewSidecarSet()
	for _, set := range s.sidecars {
		for _, obj := range set.Set().UnsortedList() {
			// redact secret data from the snapshot
			obj := snapshotutils.RedactSecretData(obj)
			sidecarSet.Insert(obj.(*networking_istio_io_v1alpha3.Sidecar))
		}
	}
	snapshotMap["sidecars"] = sidecarSet.List()

	authorizationPolicySet := security_istio_io_v1beta1_sets.NewAuthorizationPolicySet()
	for _, set := range s.authorizationPolicies {
		for _, obj := range set.Set().UnsortedList() {
			// redact secret data from the snapshot
			obj := snapshotutils.RedactSecretData(obj)
			authorizationPolicySet.Insert(obj.(*security_istio_io_v1beta1.AuthorizationPolicy))
		}
	}
	snapshotMap["authorizationPolicies"] = authorizationPolicySet.List()

	rateLimitConfigSet := ratelimit_solo_io_v1alpha1_sets.NewRateLimitConfigSet()
	for _, set := range s.rateLimitConfigs {
		for _, obj := range set.Set().UnsortedList() {
			// redact secret data from the snapshot
			obj := snapshotutils.RedactSecretData(obj)
			rateLimitConfigSet.Insert(obj.(*ratelimit_solo_io_v1alpha1.RateLimitConfig))
		}
	}
	snapshotMap["rateLimitConfigs"] = rateLimitConfigSet.List()

	snapshotMap["clusters"] = s.clusters

	return json.Marshal(snapshotMap)
}

// LabeledIssuedCertificateSet represents a set of issuedCertificates
// which share a common set of labels.
// These labels are used to find diffs between IssuedCertificateSets.
type LabeledIssuedCertificateSet interface {
	// returns the set of Labels shared by this IssuedCertificateSet
	Labels() map[string]string

	// returns the set of IssuedCertificatees with the given labels
	Set() certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledIssuedCertificateSet struct {
	set    certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet
	labels map[string]string
}

func NewLabeledIssuedCertificateSet(set certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet, labels map[string]string) (LabeledIssuedCertificateSet, error) {
	// validate that each IssuedCertificate contains the labels, else this is not a valid LabeledIssuedCertificateSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on IssuedCertificate %v", k, v, item.Name)
			}
		}
	}

	return &labeledIssuedCertificateSet{set: set, labels: labels}, nil
}

func (l *labeledIssuedCertificateSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledIssuedCertificateSet) Set() certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet {
	return l.set
}

func (l labeledIssuedCertificateSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list certificates_mesh_gloo_solo_io_v1.IssuedCertificateList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources: desiredResources,
		ListFunc:  listFunc,
		GVK: schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "IssuedCertificate",
		},
	}
}

// LabeledPodBounceDirectiveSet represents a set of podBounceDirectives
// which share a common set of labels.
// These labels are used to find diffs between PodBounceDirectiveSets.
type LabeledPodBounceDirectiveSet interface {
	// returns the set of Labels shared by this PodBounceDirectiveSet
	Labels() map[string]string

	// returns the set of PodBounceDirectivees with the given labels
	Set() certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledPodBounceDirectiveSet struct {
	set    certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet
	labels map[string]string
}

func NewLabeledPodBounceDirectiveSet(set certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet, labels map[string]string) (LabeledPodBounceDirectiveSet, error) {
	// validate that each PodBounceDirective contains the labels, else this is not a valid LabeledPodBounceDirectiveSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on PodBounceDirective %v", k, v, item.Name)
			}
		}
	}

	return &labeledPodBounceDirectiveSet{set: set, labels: labels}, nil
}

func (l *labeledPodBounceDirectiveSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledPodBounceDirectiveSet) Set() certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet {
	return l.set
}

func (l labeledPodBounceDirectiveSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list certificates_mesh_gloo_solo_io_v1.PodBounceDirectiveList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources: desiredResources,
		ListFunc:  listFunc,
		GVK: schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "PodBounceDirective",
		},
	}
}

// LabeledXdsConfigSet represents a set of xdsConfigs
// which share a common set of labels.
// These labels are used to find diffs between XdsConfigSets.
type LabeledXdsConfigSet interface {
	// returns the set of Labels shared by this XdsConfigSet
	Labels() map[string]string

	// returns the set of XdsConfiges with the given labels
	Set() xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.XdsConfigSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledXdsConfigSet struct {
	set    xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.XdsConfigSet
	labels map[string]string
}

func NewLabeledXdsConfigSet(set xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.XdsConfigSet, labels map[string]string) (LabeledXdsConfigSet, error) {
	// validate that each XdsConfig contains the labels, else this is not a valid LabeledXdsConfigSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on XdsConfig %v", k, v, item.Name)
			}
		}
	}

	return &labeledXdsConfigSet{set: set, labels: labels}, nil
}

func (l *labeledXdsConfigSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledXdsConfigSet) Set() xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.XdsConfigSet {
	return l.set
}

func (l labeledXdsConfigSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list xds_agent_enterprise_mesh_gloo_solo_io_v1beta1.XdsConfigList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources: desiredResources,
		ListFunc:  listFunc,
		GVK: schema.GroupVersionKind{
			Group:   "xds.agent.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "XdsConfig",
		},
	}
}

// LabeledDestinationRuleSet represents a set of destinationRules
// which share a common set of labels.
// These labels are used to find diffs between DestinationRuleSets.
type LabeledDestinationRuleSet interface {
	// returns the set of Labels shared by this DestinationRuleSet
	Labels() map[string]string

	// returns the set of DestinationRulees with the given labels
	Set() networking_istio_io_v1alpha3_sets.DestinationRuleSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledDestinationRuleSet struct {
	set    networking_istio_io_v1alpha3_sets.DestinationRuleSet
	labels map[string]string
}

func NewLabeledDestinationRuleSet(set networking_istio_io_v1alpha3_sets.DestinationRuleSet, labels map[string]string) (LabeledDestinationRuleSet, error) {
	// validate that each DestinationRule contains the labels, else this is not a valid LabeledDestinationRuleSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on DestinationRule %v", k, v, item.Name)
			}
		}
	}

	return &labeledDestinationRuleSet{set: set, labels: labels}, nil
}

func (l *labeledDestinationRuleSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledDestinationRuleSet) Set() networking_istio_io_v1alpha3_sets.DestinationRuleSet {
	return l.set
}

func (l labeledDestinationRuleSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list networking_istio_io_v1alpha3.DestinationRuleList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources: desiredResources,
		ListFunc:  listFunc,
		GVK: schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "DestinationRule",
		},
	}
}

// LabeledEnvoyFilterSet represents a set of envoyFilters
// which share a common set of labels.
// These labels are used to find diffs between EnvoyFilterSets.
type LabeledEnvoyFilterSet interface {
	// returns the set of Labels shared by this EnvoyFilterSet
	Labels() map[string]string

	// returns the set of EnvoyFilteres with the given labels
	Set() networking_istio_io_v1alpha3_sets.EnvoyFilterSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledEnvoyFilterSet struct {
	set    networking_istio_io_v1alpha3_sets.EnvoyFilterSet
	labels map[string]string
}

func NewLabeledEnvoyFilterSet(set networking_istio_io_v1alpha3_sets.EnvoyFilterSet, labels map[string]string) (LabeledEnvoyFilterSet, error) {
	// validate that each EnvoyFilter contains the labels, else this is not a valid LabeledEnvoyFilterSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on EnvoyFilter %v", k, v, item.Name)
			}
		}
	}

	return &labeledEnvoyFilterSet{set: set, labels: labels}, nil
}

func (l *labeledEnvoyFilterSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledEnvoyFilterSet) Set() networking_istio_io_v1alpha3_sets.EnvoyFilterSet {
	return l.set
}

func (l labeledEnvoyFilterSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list networking_istio_io_v1alpha3.EnvoyFilterList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources: desiredResources,
		ListFunc:  listFunc,
		GVK: schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "EnvoyFilter",
		},
	}
}

// LabeledGatewaySet represents a set of gateways
// which share a common set of labels.
// These labels are used to find diffs between GatewaySets.
type LabeledGatewaySet interface {
	// returns the set of Labels shared by this GatewaySet
	Labels() map[string]string

	// returns the set of Gatewayes with the given labels
	Set() networking_istio_io_v1alpha3_sets.GatewaySet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledGatewaySet struct {
	set    networking_istio_io_v1alpha3_sets.GatewaySet
	labels map[string]string
}

func NewLabeledGatewaySet(set networking_istio_io_v1alpha3_sets.GatewaySet, labels map[string]string) (LabeledGatewaySet, error) {
	// validate that each Gateway contains the labels, else this is not a valid LabeledGatewaySet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on Gateway %v", k, v, item.Name)
			}
		}
	}

	return &labeledGatewaySet{set: set, labels: labels}, nil
}

func (l *labeledGatewaySet) Labels() map[string]string {
	return l.labels
}

func (l *labeledGatewaySet) Set() networking_istio_io_v1alpha3_sets.GatewaySet {
	return l.set
}

func (l labeledGatewaySet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list networking_istio_io_v1alpha3.GatewayList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources: desiredResources,
		ListFunc:  listFunc,
		GVK: schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "Gateway",
		},
	}
}

// LabeledServiceEntrySet represents a set of serviceEntries
// which share a common set of labels.
// These labels are used to find diffs between ServiceEntrySets.
type LabeledServiceEntrySet interface {
	// returns the set of Labels shared by this ServiceEntrySet
	Labels() map[string]string

	// returns the set of ServiceEntryes with the given labels
	Set() networking_istio_io_v1alpha3_sets.ServiceEntrySet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledServiceEntrySet struct {
	set    networking_istio_io_v1alpha3_sets.ServiceEntrySet
	labels map[string]string
}

func NewLabeledServiceEntrySet(set networking_istio_io_v1alpha3_sets.ServiceEntrySet, labels map[string]string) (LabeledServiceEntrySet, error) {
	// validate that each ServiceEntry contains the labels, else this is not a valid LabeledServiceEntrySet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on ServiceEntry %v", k, v, item.Name)
			}
		}
	}

	return &labeledServiceEntrySet{set: set, labels: labels}, nil
}

func (l *labeledServiceEntrySet) Labels() map[string]string {
	return l.labels
}

func (l *labeledServiceEntrySet) Set() networking_istio_io_v1alpha3_sets.ServiceEntrySet {
	return l.set
}

func (l labeledServiceEntrySet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list networking_istio_io_v1alpha3.ServiceEntryList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources: desiredResources,
		ListFunc:  listFunc,
		GVK: schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "ServiceEntry",
		},
	}
}

// LabeledVirtualServiceSet represents a set of virtualServices
// which share a common set of labels.
// These labels are used to find diffs between VirtualServiceSets.
type LabeledVirtualServiceSet interface {
	// returns the set of Labels shared by this VirtualServiceSet
	Labels() map[string]string

	// returns the set of VirtualServicees with the given labels
	Set() networking_istio_io_v1alpha3_sets.VirtualServiceSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledVirtualServiceSet struct {
	set    networking_istio_io_v1alpha3_sets.VirtualServiceSet
	labels map[string]string
}

func NewLabeledVirtualServiceSet(set networking_istio_io_v1alpha3_sets.VirtualServiceSet, labels map[string]string) (LabeledVirtualServiceSet, error) {
	// validate that each VirtualService contains the labels, else this is not a valid LabeledVirtualServiceSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on VirtualService %v", k, v, item.Name)
			}
		}
	}

	return &labeledVirtualServiceSet{set: set, labels: labels}, nil
}

func (l *labeledVirtualServiceSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledVirtualServiceSet) Set() networking_istio_io_v1alpha3_sets.VirtualServiceSet {
	return l.set
}

func (l labeledVirtualServiceSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list networking_istio_io_v1alpha3.VirtualServiceList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources: desiredResources,
		ListFunc:  listFunc,
		GVK: schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "VirtualService",
		},
	}
}

// LabeledSidecarSet represents a set of sidecars
// which share a common set of labels.
// These labels are used to find diffs between SidecarSets.
type LabeledSidecarSet interface {
	// returns the set of Labels shared by this SidecarSet
	Labels() map[string]string

	// returns the set of Sidecares with the given labels
	Set() networking_istio_io_v1alpha3_sets.SidecarSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledSidecarSet struct {
	set    networking_istio_io_v1alpha3_sets.SidecarSet
	labels map[string]string
}

func NewLabeledSidecarSet(set networking_istio_io_v1alpha3_sets.SidecarSet, labels map[string]string) (LabeledSidecarSet, error) {
	// validate that each Sidecar contains the labels, else this is not a valid LabeledSidecarSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on Sidecar %v", k, v, item.Name)
			}
		}
	}

	return &labeledSidecarSet{set: set, labels: labels}, nil
}

func (l *labeledSidecarSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledSidecarSet) Set() networking_istio_io_v1alpha3_sets.SidecarSet {
	return l.set
}

func (l labeledSidecarSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list networking_istio_io_v1alpha3.SidecarList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources: desiredResources,
		ListFunc:  listFunc,
		GVK: schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "Sidecar",
		},
	}
}

// LabeledAuthorizationPolicySet represents a set of authorizationPolicies
// which share a common set of labels.
// These labels are used to find diffs between AuthorizationPolicySets.
type LabeledAuthorizationPolicySet interface {
	// returns the set of Labels shared by this AuthorizationPolicySet
	Labels() map[string]string

	// returns the set of AuthorizationPolicyes with the given labels
	Set() security_istio_io_v1beta1_sets.AuthorizationPolicySet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledAuthorizationPolicySet struct {
	set    security_istio_io_v1beta1_sets.AuthorizationPolicySet
	labels map[string]string
}

func NewLabeledAuthorizationPolicySet(set security_istio_io_v1beta1_sets.AuthorizationPolicySet, labels map[string]string) (LabeledAuthorizationPolicySet, error) {
	// validate that each AuthorizationPolicy contains the labels, else this is not a valid LabeledAuthorizationPolicySet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on AuthorizationPolicy %v", k, v, item.Name)
			}
		}
	}

	return &labeledAuthorizationPolicySet{set: set, labels: labels}, nil
}

func (l *labeledAuthorizationPolicySet) Labels() map[string]string {
	return l.labels
}

func (l *labeledAuthorizationPolicySet) Set() security_istio_io_v1beta1_sets.AuthorizationPolicySet {
	return l.set
}

func (l labeledAuthorizationPolicySet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list security_istio_io_v1beta1.AuthorizationPolicyList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources: desiredResources,
		ListFunc:  listFunc,
		GVK: schema.GroupVersionKind{
			Group:   "security.istio.io",
			Version: "v1beta1",
			Kind:    "AuthorizationPolicy",
		},
	}
}

// LabeledRateLimitConfigSet represents a set of rateLimitConfigs
// which share a common set of labels.
// These labels are used to find diffs between RateLimitConfigSets.
type LabeledRateLimitConfigSet interface {
	// returns the set of Labels shared by this RateLimitConfigSet
	Labels() map[string]string

	// returns the set of RateLimitConfiges with the given labels
	Set() ratelimit_solo_io_v1alpha1_sets.RateLimitConfigSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledRateLimitConfigSet struct {
	set    ratelimit_solo_io_v1alpha1_sets.RateLimitConfigSet
	labels map[string]string
}

func NewLabeledRateLimitConfigSet(set ratelimit_solo_io_v1alpha1_sets.RateLimitConfigSet, labels map[string]string) (LabeledRateLimitConfigSet, error) {
	// validate that each RateLimitConfig contains the labels, else this is not a valid LabeledRateLimitConfigSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on RateLimitConfig %v", k, v, item.Name)
			}
		}
	}

	return &labeledRateLimitConfigSet{set: set, labels: labels}, nil
}

func (l *labeledRateLimitConfigSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledRateLimitConfigSet) Set() ratelimit_solo_io_v1alpha1_sets.RateLimitConfigSet {
	return l.set
}

func (l labeledRateLimitConfigSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list ratelimit_solo_io_v1alpha1.RateLimitConfigList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources: desiredResources,
		ListFunc:  listFunc,
		GVK: schema.GroupVersionKind{
			Group:   "ratelimit.solo.io",
			Version: "v1alpha1",
			Kind:    "RateLimitConfig",
		},
	}
}

type builder struct {
	ctx      context.Context
	name     string
	clusters []string

	issuedCertificates  certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet
	podBounceDirectives certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet

	xdsConfigs xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.XdsConfigSet

	destinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet
	envoyFilters     networking_istio_io_v1alpha3_sets.EnvoyFilterSet
	gateways         networking_istio_io_v1alpha3_sets.GatewaySet
	serviceEntries   networking_istio_io_v1alpha3_sets.ServiceEntrySet
	virtualServices  networking_istio_io_v1alpha3_sets.VirtualServiceSet
	sidecars         networking_istio_io_v1alpha3_sets.SidecarSet

	authorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet

	rateLimitConfigs ratelimit_solo_io_v1alpha1_sets.RateLimitConfigSet
}

func NewBuilder(ctx context.Context, name string) *builder {
	return &builder{
		ctx:  ctx,
		name: name,

		issuedCertificates:  certificates_mesh_gloo_solo_io_v1_sets.NewIssuedCertificateSet(),
		podBounceDirectives: certificates_mesh_gloo_solo_io_v1_sets.NewPodBounceDirectiveSet(),

		xdsConfigs: xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewXdsConfigSet(),

		destinationRules: networking_istio_io_v1alpha3_sets.NewDestinationRuleSet(),
		envoyFilters:     networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet(),
		gateways:         networking_istio_io_v1alpha3_sets.NewGatewaySet(),
		serviceEntries:   networking_istio_io_v1alpha3_sets.NewServiceEntrySet(),
		virtualServices:  networking_istio_io_v1alpha3_sets.NewVirtualServiceSet(),
		sidecars:         networking_istio_io_v1alpha3_sets.NewSidecarSet(),

		authorizationPolicies: security_istio_io_v1beta1_sets.NewAuthorizationPolicySet(),

		rateLimitConfigs: ratelimit_solo_io_v1alpha1_sets.NewRateLimitConfigSet(),
	}
}

// the output Builder uses a builder pattern to allow
// iteratively collecting outputs before producing a final snapshot
type Builder interface {

	// add IssuedCertificates to the collected outputs
	AddIssuedCertificates(issuedCertificates ...*certificates_mesh_gloo_solo_io_v1.IssuedCertificate)

	// get the collected IssuedCertificates
	GetIssuedCertificates() certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet

	// add PodBounceDirectives to the collected outputs
	AddPodBounceDirectives(podBounceDirectives ...*certificates_mesh_gloo_solo_io_v1.PodBounceDirective)

	// get the collected PodBounceDirectives
	GetPodBounceDirectives() certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet

	// add XdsConfigs to the collected outputs
	AddXdsConfigs(xdsConfigs ...*xds_agent_enterprise_mesh_gloo_solo_io_v1beta1.XdsConfig)

	// get the collected XdsConfigs
	GetXdsConfigs() xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.XdsConfigSet

	// add DestinationRules to the collected outputs
	AddDestinationRules(destinationRules ...*networking_istio_io_v1alpha3.DestinationRule)

	// get the collected DestinationRules
	GetDestinationRules() networking_istio_io_v1alpha3_sets.DestinationRuleSet

	// add EnvoyFilters to the collected outputs
	AddEnvoyFilters(envoyFilters ...*networking_istio_io_v1alpha3.EnvoyFilter)

	// get the collected EnvoyFilters
	GetEnvoyFilters() networking_istio_io_v1alpha3_sets.EnvoyFilterSet

	// add Gateways to the collected outputs
	AddGateways(gateways ...*networking_istio_io_v1alpha3.Gateway)

	// get the collected Gateways
	GetGateways() networking_istio_io_v1alpha3_sets.GatewaySet

	// add ServiceEntries to the collected outputs
	AddServiceEntries(serviceEntries ...*networking_istio_io_v1alpha3.ServiceEntry)

	// get the collected ServiceEntries
	GetServiceEntries() networking_istio_io_v1alpha3_sets.ServiceEntrySet

	// add VirtualServices to the collected outputs
	AddVirtualServices(virtualServices ...*networking_istio_io_v1alpha3.VirtualService)

	// get the collected VirtualServices
	GetVirtualServices() networking_istio_io_v1alpha3_sets.VirtualServiceSet

	// add Sidecars to the collected outputs
	AddSidecars(sidecars ...*networking_istio_io_v1alpha3.Sidecar)

	// get the collected Sidecars
	GetSidecars() networking_istio_io_v1alpha3_sets.SidecarSet

	// add AuthorizationPolicies to the collected outputs
	AddAuthorizationPolicies(authorizationPolicies ...*security_istio_io_v1beta1.AuthorizationPolicy)

	// get the collected AuthorizationPolicies
	GetAuthorizationPolicies() security_istio_io_v1beta1_sets.AuthorizationPolicySet

	// add RateLimitConfigs to the collected outputs
	AddRateLimitConfigs(rateLimitConfigs ...*ratelimit_solo_io_v1alpha1.RateLimitConfig)

	// get the collected RateLimitConfigs
	GetRateLimitConfigs() ratelimit_solo_io_v1alpha1_sets.RateLimitConfigSet

	// build the collected outputs into a label-partitioned snapshot
	BuildLabelPartitionedSnapshot(labelKey string) (Snapshot, error)

	// build the collected outputs into a snapshot with a single partition
	BuildSinglePartitionedSnapshot(snapshotLabels map[string]string) (Snapshot, error)

	// add a cluster to the collected clusters.
	// this can be used to collect clusters for use with MultiCluster snapshots.
	AddCluster(cluster string)

	// returns the set of clusters currently stored in this builder
	Clusters() []string

	// merge all the resources from another Builder into this one
	Merge(other Builder)

	// create a clone of this builder (deepcopying all resources)
	Clone() Builder

	// convert this snapshot to its generic form
	Generic() resource.ClusterSnapshot

	// iterate over the objects contained in the snapshot
	ForEachObject(handleObject func(cluster string, gvk schema.GroupVersionKind, obj resource.TypedObject))
}

func (b *builder) AddIssuedCertificates(issuedCertificates ...*certificates_mesh_gloo_solo_io_v1.IssuedCertificate) {
	for _, obj := range issuedCertificates {
		if obj == nil {
			continue
		}
		b.issuedCertificates.Insert(obj)
	}
}
func (b *builder) AddPodBounceDirectives(podBounceDirectives ...*certificates_mesh_gloo_solo_io_v1.PodBounceDirective) {
	for _, obj := range podBounceDirectives {
		if obj == nil {
			continue
		}
		b.podBounceDirectives.Insert(obj)
	}
}
func (b *builder) AddXdsConfigs(xdsConfigs ...*xds_agent_enterprise_mesh_gloo_solo_io_v1beta1.XdsConfig) {
	for _, obj := range xdsConfigs {
		if obj == nil {
			continue
		}
		b.xdsConfigs.Insert(obj)
	}
}
func (b *builder) AddDestinationRules(destinationRules ...*networking_istio_io_v1alpha3.DestinationRule) {
	for _, obj := range destinationRules {
		if obj == nil {
			continue
		}
		b.destinationRules.Insert(obj)
	}
}
func (b *builder) AddEnvoyFilters(envoyFilters ...*networking_istio_io_v1alpha3.EnvoyFilter) {
	for _, obj := range envoyFilters {
		if obj == nil {
			continue
		}
		b.envoyFilters.Insert(obj)
	}
}
func (b *builder) AddGateways(gateways ...*networking_istio_io_v1alpha3.Gateway) {
	for _, obj := range gateways {
		if obj == nil {
			continue
		}
		b.gateways.Insert(obj)
	}
}
func (b *builder) AddServiceEntries(serviceEntries ...*networking_istio_io_v1alpha3.ServiceEntry) {
	for _, obj := range serviceEntries {
		if obj == nil {
			continue
		}
		b.serviceEntries.Insert(obj)
	}
}
func (b *builder) AddVirtualServices(virtualServices ...*networking_istio_io_v1alpha3.VirtualService) {
	for _, obj := range virtualServices {
		if obj == nil {
			continue
		}
		b.virtualServices.Insert(obj)
	}
}
func (b *builder) AddSidecars(sidecars ...*networking_istio_io_v1alpha3.Sidecar) {
	for _, obj := range sidecars {
		if obj == nil {
			continue
		}
		b.sidecars.Insert(obj)
	}
}
func (b *builder) AddAuthorizationPolicies(authorizationPolicies ...*security_istio_io_v1beta1.AuthorizationPolicy) {
	for _, obj := range authorizationPolicies {
		if obj == nil {
			continue
		}
		b.authorizationPolicies.Insert(obj)
	}
}
func (b *builder) AddRateLimitConfigs(rateLimitConfigs ...*ratelimit_solo_io_v1alpha1.RateLimitConfig) {
	for _, obj := range rateLimitConfigs {
		if obj == nil {
			continue
		}
		b.rateLimitConfigs.Insert(obj)
	}
}

func (b *builder) GetIssuedCertificates() certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet {
	return b.issuedCertificates
}
func (b *builder) GetPodBounceDirectives() certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet {
	return b.podBounceDirectives
}

func (b *builder) GetXdsConfigs() xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.XdsConfigSet {
	return b.xdsConfigs
}

func (b *builder) GetDestinationRules() networking_istio_io_v1alpha3_sets.DestinationRuleSet {
	return b.destinationRules
}
func (b *builder) GetEnvoyFilters() networking_istio_io_v1alpha3_sets.EnvoyFilterSet {
	return b.envoyFilters
}
func (b *builder) GetGateways() networking_istio_io_v1alpha3_sets.GatewaySet {
	return b.gateways
}
func (b *builder) GetServiceEntries() networking_istio_io_v1alpha3_sets.ServiceEntrySet {
	return b.serviceEntries
}
func (b *builder) GetVirtualServices() networking_istio_io_v1alpha3_sets.VirtualServiceSet {
	return b.virtualServices
}
func (b *builder) GetSidecars() networking_istio_io_v1alpha3_sets.SidecarSet {
	return b.sidecars
}

func (b *builder) GetAuthorizationPolicies() security_istio_io_v1beta1_sets.AuthorizationPolicySet {
	return b.authorizationPolicies
}

func (b *builder) GetRateLimitConfigs() ratelimit_solo_io_v1alpha1_sets.RateLimitConfigSet {
	return b.rateLimitConfigs
}

func (b *builder) BuildLabelPartitionedSnapshot(labelKey string) (Snapshot, error) {
	return NewLabelPartitionedSnapshot(
		b.name,
		labelKey,

		b.issuedCertificates,
		b.podBounceDirectives,

		b.xdsConfigs,

		b.destinationRules,
		b.envoyFilters,
		b.gateways,
		b.serviceEntries,
		b.virtualServices,
		b.sidecars,

		b.authorizationPolicies,

		b.rateLimitConfigs,
		b.clusters...,
	)
}

func (b *builder) BuildSinglePartitionedSnapshot(snapshotLabels map[string]string) (Snapshot, error) {
	return NewSinglePartitionedSnapshot(
		b.name,
		snapshotLabels,

		b.issuedCertificates,
		b.podBounceDirectives,

		b.xdsConfigs,

		b.destinationRules,
		b.envoyFilters,
		b.gateways,
		b.serviceEntries,
		b.virtualServices,
		b.sidecars,

		b.authorizationPolicies,

		b.rateLimitConfigs,
		b.clusters...,
	)
}

func (b *builder) AddCluster(cluster string) {
	b.clusters = append(b.clusters, cluster)
}

func (b *builder) Clusters() []string {
	return b.clusters
}

func (b *builder) Merge(other Builder) {
	if other == nil {
		return
	}

	b.AddIssuedCertificates(other.GetIssuedCertificates().List()...)
	b.AddPodBounceDirectives(other.GetPodBounceDirectives().List()...)

	b.AddXdsConfigs(other.GetXdsConfigs().List()...)

	b.AddDestinationRules(other.GetDestinationRules().List()...)
	b.AddEnvoyFilters(other.GetEnvoyFilters().List()...)
	b.AddGateways(other.GetGateways().List()...)
	b.AddServiceEntries(other.GetServiceEntries().List()...)
	b.AddVirtualServices(other.GetVirtualServices().List()...)
	b.AddSidecars(other.GetSidecars().List()...)

	b.AddAuthorizationPolicies(other.GetAuthorizationPolicies().List()...)

	b.AddRateLimitConfigs(other.GetRateLimitConfigs().List()...)
	for _, cluster := range other.Clusters() {
		b.AddCluster(cluster)
	}
}

func (b *builder) Clone() Builder {
	if b == nil {
		return nil
	}
	clone := NewBuilder(b.ctx, b.name)

	for _, issuedCertificate := range b.GetIssuedCertificates().List() {
		clone.AddIssuedCertificates(issuedCertificate.DeepCopy())
	}
	for _, podBounceDirective := range b.GetPodBounceDirectives().List() {
		clone.AddPodBounceDirectives(podBounceDirective.DeepCopy())
	}

	for _, xdsConfig := range b.GetXdsConfigs().List() {
		clone.AddXdsConfigs(xdsConfig.DeepCopy())
	}

	for _, destinationRule := range b.GetDestinationRules().List() {
		clone.AddDestinationRules(destinationRule.DeepCopy())
	}
	for _, envoyFilter := range b.GetEnvoyFilters().List() {
		clone.AddEnvoyFilters(envoyFilter.DeepCopy())
	}
	for _, gateway := range b.GetGateways().List() {
		clone.AddGateways(gateway.DeepCopy())
	}
	for _, serviceEntry := range b.GetServiceEntries().List() {
		clone.AddServiceEntries(serviceEntry.DeepCopy())
	}
	for _, virtualService := range b.GetVirtualServices().List() {
		clone.AddVirtualServices(virtualService.DeepCopy())
	}
	for _, sidecar := range b.GetSidecars().List() {
		clone.AddSidecars(sidecar.DeepCopy())
	}

	for _, authorizationPolicy := range b.GetAuthorizationPolicies().List() {
		clone.AddAuthorizationPolicies(authorizationPolicy.DeepCopy())
	}

	for _, rateLimitConfig := range b.GetRateLimitConfigs().List() {
		clone.AddRateLimitConfigs(rateLimitConfig.DeepCopy())
	}
	for _, cluster := range b.Clusters() {
		clone.AddCluster(cluster)
	}
	return clone
}

// convert this snapshot to its generic form
func (b *builder) Generic() resource.ClusterSnapshot {
	if b == nil {
		return nil
	}
	clusterSnapshots := resource.ClusterSnapshot{}

	for _, obj := range b.GetIssuedCertificates().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "IssuedCertificate",
		}
		clusterSnapshots.Insert(cluster, gvk, obj)
	}
	for _, obj := range b.GetPodBounceDirectives().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "PodBounceDirective",
		}
		clusterSnapshots.Insert(cluster, gvk, obj)
	}

	for _, obj := range b.GetXdsConfigs().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "xds.agent.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "XdsConfig",
		}
		clusterSnapshots.Insert(cluster, gvk, obj)
	}

	for _, obj := range b.GetDestinationRules().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "DestinationRule",
		}
		clusterSnapshots.Insert(cluster, gvk, obj)
	}
	for _, obj := range b.GetEnvoyFilters().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "EnvoyFilter",
		}
		clusterSnapshots.Insert(cluster, gvk, obj)
	}
	for _, obj := range b.GetGateways().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "Gateway",
		}
		clusterSnapshots.Insert(cluster, gvk, obj)
	}
	for _, obj := range b.GetServiceEntries().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "ServiceEntry",
		}
		clusterSnapshots.Insert(cluster, gvk, obj)
	}
	for _, obj := range b.GetVirtualServices().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "VirtualService",
		}
		clusterSnapshots.Insert(cluster, gvk, obj)
	}
	for _, obj := range b.GetSidecars().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "Sidecar",
		}
		clusterSnapshots.Insert(cluster, gvk, obj)
	}

	for _, obj := range b.GetAuthorizationPolicies().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "security.istio.io",
			Version: "v1beta1",
			Kind:    "AuthorizationPolicy",
		}
		clusterSnapshots.Insert(cluster, gvk, obj)
	}

	for _, obj := range b.GetRateLimitConfigs().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "ratelimit.solo.io",
			Version: "v1alpha1",
			Kind:    "RateLimitConfig",
		}
		clusterSnapshots.Insert(cluster, gvk, obj)
	}

	return clusterSnapshots
}

// convert this snapshot to its generic form
func (b *builder) ForEachObject(handleObject func(cluster string, gvk schema.GroupVersionKind, obj resource.TypedObject)) {
	if b == nil {
		return
	}

	for _, obj := range b.GetIssuedCertificates().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "IssuedCertificate",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range b.GetPodBounceDirectives().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "PodBounceDirective",
		}
		handleObject(cluster, gvk, obj)
	}

	for _, obj := range b.GetXdsConfigs().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "xds.agent.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "XdsConfig",
		}
		handleObject(cluster, gvk, obj)
	}

	for _, obj := range b.GetDestinationRules().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "DestinationRule",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range b.GetEnvoyFilters().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "EnvoyFilter",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range b.GetGateways().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "Gateway",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range b.GetServiceEntries().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "ServiceEntry",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range b.GetVirtualServices().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "VirtualService",
		}
		handleObject(cluster, gvk, obj)
	}
	for _, obj := range b.GetSidecars().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "Sidecar",
		}
		handleObject(cluster, gvk, obj)
	}

	for _, obj := range b.GetAuthorizationPolicies().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "security.istio.io",
			Version: "v1beta1",
			Kind:    "AuthorizationPolicy",
		}
		handleObject(cluster, gvk, obj)
	}

	for _, obj := range b.GetRateLimitConfigs().List() {
		cluster := obj.GetClusterName()
		gvk := schema.GroupVersionKind{
			Group:   "ratelimit.solo.io",
			Version: "v1alpha1",
			Kind:    "RateLimitConfig",
		}
		handleObject(cluster, gvk, obj)
	}
}
